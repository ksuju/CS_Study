## Chapter01 - 컴퓨터 구조 시작하기

### 1. 컴퓨터 구조를 알아야 하는 이유
- 컴퓨터 구조를 이해하면 코드 이외의 부분에서 문제 진단 가능 > 문제 해결 능력이 향상됨

- 성능/용량/비용을 고려하며 개발할 수 있음

 

### 2. 컴퓨터 구조의 큰 그림
* 컴퓨터가 이해하는 정보
1) 데이터 : 컴퓨터와 주고받는 정보나 컴퓨터에 저장된 정보

2) 명령어 : 데이터를 움직이고, 컴퓨터를 작동시키는 정보

** 컴퓨터란 무엇? -> "컴퓨터는 명령어를 처리하는 기계!"

 

 

#### * 컴퓨터의 네 가지 핵심 부품
#### 1) 중앙처리장치 (CPU)

- 메모리에 저장된 명령어를 읽어 들이고, 해석하고, 실행

 

** CPU 내부 구성 요소

1-1) 산술논리연산장치(ALU) :

     - 계산기!, 컴퓨터 내부에서 수행되는 대부분의 계산 담당

 

1-2) 레지스터 :

     - CPU 내부의 작은 임시 저장 장치

 

1-3) 제어장치 :

     - "제어 신호"라는 전기 신호를 내보내고, 명령어를 해석하는 장치

     - CPU가 메모리에 저장된 값을 읽고 싶을 땐 메모리를 향해 "메모리 읽기" 라는 제어 신호를 보냄

     - CPU가 메모리에 값을 저장하고 싶을 땐 메모리를 향해 "메모리 쓰기"라는 제어 신호를 보냄

 

** CPU의 동작 흐름

- 메모리가 명령어를 CPU에 전달 > 레지스터에 저장 > 제어장치가 명령어를 해석 > 메모리에 제어 신호 보냄

 

 

 

#### 2) 주기억장치 (메모리) = RAM

- 휘발성

- 현재 실행되는 프로그램의 명령어와 데이터를 저장하는 부품

- 프로그램이 실행되기 위해서는 반드시 메모리에 저장되어 있어야 함

- 메모리는 현재 실행되는 프로그램의 명령어와 데이터를 저장함

- 메모리에 저장된 값의 위치는 주소로 알 수 있음

 

#### 3) 보조기억장치

- 메모리보다 크기가 크고 전원이 꺼져도 저장된 내용을 잃지 않는, 메모리를 보조할 저장 장치

- HDD, SSD ,USB, DVD, CD-ROM 등

 

#### 4) 입출력장치

- 컴퓨터 외부에 연결되어 컴퓨터 내부와 정보를 교환하는 장치

- 마이크, 모니터, 키보드 등

 

 

* 메인보드와 시스템 버스 ( 버스 = 통로 )
1) 메인보드 :

- 위에 설명한 컴퓨터의 핵심 부품들이 연결되는 부품

- 메인보드 내부에 있는 버스라는 통로를 통해 부품간 정보를 주고받음

 

2) 시스템 버스 :

- 네가지 핵심 부품들이 서로 정보를 주고받는 통로

2-1) 주소 버스 : RAM 주소의 통로

2-2) 데이터 버스 : 데이터 통로

2-3) 제어 버스 : 제어 신호 통로


## Chapter02 - 0과 1로 숫자를 표현하는 방법


1바이트 = 8비트

 

### 이진법
이진수의 음수 표현
2의 보수를 구해 그 값을 음수로 간주한다!

 

#### "모든 0과 1을 뒤집고, 거기에 1을 더한 값" 이 보수다!

 

ex) 1011의 음수는?

1. 모든 수를 뒤집음 -> 0100

2. 거기에 1을 더함 -> 0101

 

### 플래그 :

- 숫자만 보고는 이진수가 음수인지 양수인지 알 수 없기에 사용함! > 04장에서 정리

 

 

### 십육진법
십진수

0 - 1 - 2 - 3 - 4 - 5 - 6 - 7 - 8 - 9 - 10 - 11 - 12 - 13 - 14 - 15 - 16 - 17 ~~

 

십육진수

0 - 1 - 2 - 3 - 4 - 5 - 6 - 7 - 8 - 9 - A - B - C - D - E - F - 10 - 11 - 12 ~~

 

* 십육진수를 사용하는 이유?

- 이진수를 십육진수로, 십육진수를 이진수로 변환하기 쉽기 때문에!

 

십육진수를 이진수로 변환하기 :

십육진수 한 글자를 4비트의 이진수로 간주하면 됨!

 

1A2B를 변환하면?

1 = 0001

A = 1010

2 = 0010

B = 1011

 

0001101000101011 = 1A2B

 

 

### 이진수를 십육진수로 변환하기 :

반대로! 이진수 숫자를 네 개씩 끊고, 하나의 십육진수로 변환한 뒤 그대로 이어 붙인다

 

11010101을 변환하면?

1101 = D

0101 = 5

 

11010101 = D5



### 0과 1로 문자를 표현하는 방법
문자 집합 :
- 컴퓨터가 인식할 수 있는 문자의 모음, 문자 집합에 속한 문자를 인코딩하여 0과 1로 표현 가능

 

#### 인코딩 :
- 문자를 컴퓨터가 이해할 수 있는 0과 1로 변환하는 과정

 

#### 디코딩 :
- 0과 1로 표현된 문자 코드를 사람이 읽을 수 있는 문자로 변환하는 과정

 

#### EUC-KR :
- 한글을 2바이트 크기로 인코딩할 수 있는 완성형 인코딩 방식
- 다만, 한글 전체를 표현하기는 힘들다 (쀍, 믜 같은 글자는 표현 불가능)

 

#### 유니코드와 UTF-8
- EUC-KR의 모든 한글을 표현할 수 없다는 단점을 보완하는 인코딩 방식
- 유니코드는 현대 문자를 표현할 때 가장 많이 사용되는 표준 문자 집합이다!
- UTF-8은 유니코드 문자의 인코딩 방식 중 하나, UTF-8, 16, 32가 있음


## Chapter03 - 명령어

### **1\. 소스 코드와 명령어**

\- 모든 소스 코드는 컴퓨터 내부에서 명령어로 변환됨!

#### **\* 고급 언어와 저급 언어**

**1) 고급 언어 :**

\- 사람을 위한 언어

**2) 저급 언어 :**

\- 컴퓨터가 직접 이해하고 실행할 수 있는 언어, 컴퓨터는 오직 저급언어만 이해하고 실행 가능함

#### **\* 저급 언어의 종류**

**1) 기계어 :**

\- 0과 1의 명령어 비트로 이루어진 언어

\- 보통은 2진수로 표현, 가독성을 위해 16진수로 표현하기도 함

**2) 어셈블리어**

\- 기계어를 읽기 편한 형태로 번역한 언어

\- 임베디드, 게임, 정보 보안 분야 등에서 많이 사용됨

#### **\* 고급 언어의 종류, 컴파일 언어와 인터프리터 언어 :**

고급 언어가 저급 언어로 변환되는 방식

**1) 컴파일 방식 (컴파일 언어)**

\- 컴파일러에 의해 **소스 코드 전체**가 저급 언어로 변환되어 실행되는 고급 언어

\- 대표적으로 C가 있음

\- 컴파일러란 컴파일을 수행해주는 도구

\- 컴파일러를 통해 저급 언어로 변환된 코드를 목적 코드라고 함

**2) 인터프리트 방식 (인터프리터 언어)**

\- 대표적으로 Python이 있음

\- 소스 코드를 **한 줄씩 차례로** 저급 언어로 변환

\- 한 줄씩 코드를 실행하기 때문에 N번째 줄에 문법 오류가 있어도, N-1 번째 줄까지는 올바르게 인터프리트 됨

\- 일반적으로 컴파일 언어보다 느리다!

현대의 많은 프로그래밍 언어는 컴파일 방식과 인터프리트 방식을 혼합해서 사용한다!

참고)

목적 파일 vs 실행 파일

\- 목적코드로 이루어진 목적 파일

\- 실행 코드로 이루어진 실행 파일

\- 목적 코드가 실행 파일이 되기 위해서는 '링킹' 이라는 작업을 거쳐야 함

### **\* 연산 코드와 오퍼랜드 :**

**명령어는 연산 코드와 오퍼랜드로 구성되어 있음**

하나의 명령어는 아래와 같이 표현될 수 있음

연산 코드가 담기는 영역 : 연산 코드 필드

오퍼랜드가 담기는 영역 : 오퍼랜드 필드

| **연산 코드** | **오퍼랜드** |
| --- | --- |

**1) 연산 코드 : 명령어가 수행할 연산 (= 연산자)**

기본적인 연산 코드 유형

\- 데이터 전송

\- 산술/논리 연산

\- 제어 흐름 변경

\- 입출력 제어

**2) 오퍼랜드 : 연산에 사용할 데이터가 저장된 위치 (= 피연산자)**

\- 메모리 주소나 레지스터 이름이 담긴다

\- **주소 필드**라고 부른다

\- 명령어 안에 하나도 없을 수도 있고, 여러 개 있을 수도 있음

\- 주소를 지정함으로서 메모리를 더 효율적으로 사용 가능함

\- 오퍼랜드에 담긴 주소, 즉, 연산의 대상이 되는 데이터가 저장된 위치를 **유효 주소**라고 함

**2-1) 주소 지정 방식**

\- 오퍼랜드 필드에 데이터가 저장된 위치를 명시할 때, 연산에 사용할 데이터 위치를 찾는 방법

\- 즉시 주소 지정 방식 :

가장 간단함, 데이터를 오퍼랜드 필드에 직접 명시하는 방법

\- 직접 주소 지정 방식 :

오퍼랜드 필드에 유효 주소를 직접적으로 명시

\- 간접 주소 지정 방식 :

유효 주소의 주소를 오퍼랜드 필드에 명시함, 다만 두 번의 메모리 접근이 필요해서 느림

\- 레지스터 주소 지정 방식 :

직접 주소 지정 방식과 비슷, 연산에 사용할 데이터를 저장한 레지스터를 오퍼랜드 필드에 직접 명시

\- 레지스터 간접 주소 지정 방식 :

연산에 사용할 데이터를 메모리에 저장하고, 그 주소를 저장 한 레지스터를 오퍼랜드 필드에 명시

**\* 스택과 큐**

스택 : LIFO

\- 후입 선출

큐 : FIFO

\- 선입 선출
